
# Http Request Correlation Specification

In order to track a complex operation in a multi-tiered system tied together using 
HTTP requests, it is extremely valuable to track which requests were generated as 
the result of a top-most 'user level' operation. To do this tracking, each request
needs to have an ID that uniquely identifies the request so that parent-child 
relationships among requests can be tracked.    

If requests are sent via HTTP, it is necessary to pass this ID along with the HTTP 
packet itself.  In systems where a single vendor controls communication on both sides 
of the HTTP pipeline, it is relatively simple to define some vendor-specific scheme, 
which defines a request ID and passes it in the HTTP headers. Indeed today there are 
a number of such schemes, but they do not interoperate with each other. 

In an environment where users might create multi-tiered applications that use 
components from different vendors it is useful to have uniform standard for these 
IDs that would give each vendor-specific logging system the information it needs to 
trace the parent-child relationships among requests for the system as a whole. 

In addition to the need for Request IDs it is also useful if there is a mechanism 
where information can be attached to a request, which flows to all of its children
(recursively).   The [OpenTracing](http://opentracing.io/documentation/) Baggage 
concept (see [spec](https://github.com/opentracing/specification/blob/master/specification.md))
needs exactly this feature.   This mechanism can be used to propagate logging control 
information for more advanced logging features, and would likewise benefit from 
standardization.  

Ideally such a standard
1. Provides enough structure so that each vendor-specific logging system 
can get the information it needs from the parts of the system that are not
under the vendor's control (but conform to the standard)

2. Provides enough flexibility so vendors can easily modify their systems 
to conform to the standard and each vendor can innovate and provide advanced
features within its logging system.

This document attempts to describe such a standard, and the rational for the design 
choices (which should be based in the two principles above). 

# Http Header Fields

Http has the concept of a [Header Fields](https://tools.ietf.org/html/rfc7230#section-3.2)
for passing addition information with the request and this standard suggest defining  
the following new header fields.

* Request-Id : A string representing the unique identifier for this request.
* Correlation-Context:  A list of comma separated set of strings of the form KEY=VALUE.
These values are intended for control of logging systems and should be passed along
to any child requests.  

The exact syntax for the values of both of these fields is given in its own section below.  

# The Expected Environment for Using Request-Id

The fundamental use of a Request-Id is to link an activity that issues a HTTP
request with the code that runs (and produces logging messages) that services the
request.   It is useful to have a overview of how such systems typically work to frame
the design of the ID itself.  

The expectation is that the logging system has the concept like 
[OpenTracing's Span](https://github.com/opentracing/specification/blob/master/specification.md)
which represents some work being done that has a ID as well as parent-child relationships
with other Spans.   Thus there are 'top level' Spans that do not have a parent, and every
other Span remembers the ID of its parent as well as its own ID.   Somewhere in the logging
system a table will be maintained that allows a Span to be located given its ID.  Every 
logging message will also be marked with the Span that is currently active, and as a result
the logging system can group together all logging messages from any given Span (or any 
of its children).   

The requirements for the Request-ID for such an environment is pretty minimal.  It simply
needs to be unique to the Span.   The expectation is that such IDs will be generated by 
choosing a random number from a large space of possible numbers.   Number sizes from 64 bits
(8 bytes) to 128 bits (16 bytes) have been commonly used.   

The expectation is that when some 'top level' activity is running, it will generate a 
new ID and log the necessary bookkeeping information for that Span.  There may be additional
Spans generated as part of the processing but eventually an HTTP request is made.  As part
of sending the HTTP request, a new Span (with a unique ID) is created (and logged), and that 
Span's ID is inserted into the Request-Id field of the HTTP request's header.  When the request 
is received a new Span (with at new ID) is created  with a parent ID as specified by the 
Request-Id field (and logged) to represent the server side processing.   The whole sequence
can repeat in the case of nested requests.   

The result is that the logging system tags every message with the active Span, and every 
Span has an ID and its parent ID, which form a tree representing the causality of the 
execution of the multi-tiered application.  

## Improving on Flat IDs

While the system described above works, it has several disadvantages 

1. It requires a table that maps from ID -> Span that is large O(#Spans).  
2. If ANY entries in the table are missing (e.g. because some components did not log properly), 
then some parent-child chain can be broken and cannot be recovered.   Effectively potentially large
chunks of the processing of a request might become 'orphaned' and not properly attributed to 
the top-level request that was responsible for it.  

These and other limitation can be avoided if IDs are given structure.   It is common to employ
a two-level structure where IDs have the form

    TOP_LEVEL_ID - SPAN_ID

Basically all children of a given top level Span have the same prefix.    With this ID structure
given any two Spans ID, they can be determined as belonging to the same top-level processing 
simply by comparing their IDs.   This has the following advantages

1. Is very fast
2. Does not need a global table 
3. Works in the presence of missing information on intermediate Spans.   

### Hierarchical IDs

The two level structure generalizes very naturally into a multi-level (hierarchical) ID.   THus an
ID would have the form

    TOP_LEVEL_ID - LEVEL_1_ID - LEVEL_2_ID - ... - LEVEL_N_ID

which creates ID for every Span by taking the parent's ID and adding a unique suffix.   With such 
a structure, it is possible to group things not only by the top level Span but also every intermediate 
level as well.   

### Encoding Additional Information into an ID

The previous section shows how the parent-child relationship can be encoded into the ID itself.  
In general ANY information that is CONSTANT over the lifetime of the Span can be encoded into the ID 
as well without destroying its utility as an ID (which just requires uniqueness).   For example the
start time, or start location could be part of the ID.   However doing this make the ID bigger and 
generally is not worthwhile unless the information is small and high value.   Candidates for such 
information high value, small size include

1. Control information (like a verbosity bit (or bits))
2. Format and interpretation bits (e.g. what version or semantic properties of the ID)

## Fixed (Bounded) Size IDs

Generally speaking fixed sized structures are easier to implement than variable sized structure.   
Thus there is non-trivial value if the IDs can be kept to a fixed maximum size.   Indeed many existing
logging systems mandate a particular size for the IDs (typically 64 or 128 bits).  

Note that systems that mandate fixed size IDs have a problem with hierarchical IDs (which have unbounded size).  
If a fixed-sized ID system receives a ID that is to large what can it do?   The solution is hashing.
Clearly a variable sized ID can be hashed to any particular fixed size without destroying its ability
to act as a unique ID.  However if some parts of the system hash (because they are fixed size), and other
do not, then in order to compare IDs it must be possible to look at both IDs, recognize that one is hashed
and then know how to perform the hash on the other before doing the comparison.   

# The Request-ID Field

TODO COMPLETE



# The Correlation-Context Field

TODO COMPLETE

TODO: The Correlation context is straightforward if the value does not end with whitespace 
or contain newlines or commas.   We will need a standard for escaping these characters if
we wish to support arbitrary values.  

